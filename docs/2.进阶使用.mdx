---
title: 进阶使用
hide_title: true
hide_table_of_contents: false
slug: /advance-use
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

## Context
在 Pywss 中，`Context` 贯穿于单次请求的整个生命周期，也是 Pywss 用于管理请求的上下文对象。

其主要属性有：

|属性|类型|说明|
|---|---|---|
|**`ctx.app`**|`pywss.App`|根app对象|
|**`ctx.fd`**|`socket.socket`|sock句柄，一般用于写操作|
|**`ctx.rfd`**|`socket.makefile`|sock句柄，一般用于读操作|
|**`ctx.address`**|`tuple`|请求地址信息|
|**`ctx.method`**|`str`|HTTP请求方法，eg：`GET/POST/PUT/DELETE/HEAD/PATCH/OPTIONS`|
|**`ctx.version`**|`str`|HTTP协议版本号，eg：`HTTP/1.1`|
|**`ctx.url`**|`str`|HTTP请求Url地址，注意是**包含请求参数在内**的全量地址。eg：`/api/v1/query?key=value`|
|**`ctx.url_params`**|`dict`|HTTP请求参数，是基于`ctx.url`解析的结果。eg：对于`/api/v1/query?key=value`地址，此属性值为`{"key": "value"}`|
|**`ctx.route`**|`str`|HTTP请求Route路由，注意是**不包含请求参数在内**的路由，eg：`/api/v1/query`|
|**`ctx.route_params`**|`dict`|用于存储[局部匹配](#特殊路由匹配机制)下的路径参数，eg：对于`/api/v1/{name}/{age}`路由，此属性值为`{"name": "xx", "age": "xx"}`|
|**`ctx.headers`**|`dict`|HTTP请求头|
|**`ctx.cookies`**|`dict`|HTTP请求Cookie，是基于`ctx.headers["Cookie"]`解析的结果|
|**`ctx.content_length`**|`int`|HTTP请求Body大小，是基于`ctx.headers["Content-Length"]`解析的结果|
|**`ctx.content`**|`byte`|HTTP请求Body。对于需要获取原生请求场景，推荐使用`ctx.body()`|
|**`ctx.data`**|`dict`|用于Context上下文信息传递|
|**`ctx.body()`**|`func`|获取原始请求Body|
|**`ctx.json()`**|`func`|解析JSON请求，以JSON形式返回请求Body|
|**`ctx.form()`**|`func`|解析表单请求，并以JSON形式返回请求Body|
|**`ctx.set_status_code()`**|`func`|指定HTTP响应报文状态码|
|**`ctx.set_header()`**|`func`|指定HTTP响应头|
|**`ctx.set_content_type()`**|`func`|指定HTTP响应类型|
|**`ctx.set_cookie()`**|`func`|指定HTTP响应Cookie|
|**`ctx.write()`**|`func`|指定HTTP响应体|
|**`ctx.flush()`**|`func`|一般不需要自己调用，在某些特殊场景下有用，比如提前结束请求|


## 路由方法
在快速开始中，我们已经看到了一个简单的应用是如何注册路由并绑定业务模块的。

除了`get`、`post`方法之外，**Pywss** 还实现了：

|路由方法|说明|
|---|---|
|**get**|`app.get("/http-get", handler)`|
|**post**|`app.post("/http-post", handler)`|
|**head**|`app.head("/http-head", handler)`|
|**put**|`app.put("/http-put", handler)`|
|**delete**|`app.delete("/http-delete", handler)`|
|**patch**|`app.patch("/http-patch", handler)`|
|**options**|`app.options("/http-options", handler)`|
|**any**|`app.any("/http-any", handler)`，包括 Get、Post、Head、Put、Delete、Patch、Options 等在内的全部方法|
|**view**|`app.view("/http-view", ViewObject)`，基于视图风格实现，具体使用见 [**视图机制**](#视图机制) 部分|
|**view_modules**|`app.view_modules("api")`，基于 **文件即路由** 的设计理念实现，用于在大型项目下的路由管理。具体使用见 [**视图机制**](#视图机制) 部分|
|**static**|`app.static("/file-server", ".")`，注册静态文件服务，具体使用见 [**文件服务**](#文件服务) 部分|

路由处理函数`handler`仅接收一个参数，就是`pywss.Context`。


<br/>

## 特殊路由匹配机制
除了上述常规路由方法之外，**特殊路由匹配机制** 也是现代 web 框架必不可少的特点。

|特殊路由匹配机制|说明|
|---|---|
|全等匹配|`app.get("/full/match", handler)`|
|局部匹配|`app.get("/partial/match/{name}", handler)`，注意，局部变量会存储在`ctx.route_params`中|
|头部匹配|`app.get("/head/match/*", handler)`，注意，此处需以 `*` 结尾|

**_注意_**：
上述匹配机制无法同时生效，且存在优先级，即**全等匹配**优先、其次**局部匹配**、最后**头部匹配**~

<br/>

## 视图机制
**Pywss** 通过 `app.view` 实现了简单的视图机制，以便更加友好的支持 Restful 风格代码，参考如下：

```python
import pywss

class UserView:

    def http_get(self, ctx: pywss.Context):
        uid = ctx.route_params["uid"]
        ctx.write({"uid": uid, "msg": "query success"})

    def http_post(self, ctx: pywss.Context):
        uid = ctx.route_params["uid"]
        ctx.write({"uid": uid, "msg": "create success"})

def main():
    app = pywss.App()
    app.view("/api/user/{uid}", UserView())
    app.run()

if __name__ == '__main__':
    main()
```

此外，为了更好的管理大型项目，**Pywss** 支持 `app.view_modules` 来实现 **文件即路由** 的管理风格。下面是一个案例：

对于如下目录结构：
```text
- api
  - v1
    - user.py
    - role.py
  - v2
    - permission.py
```

<Tabs>
  <TabItem value="user.py" label="user.py" default>

```python
import pywss

__route__="/user"  # 指定路由，可选，默认为 /user
__view__="View"  # 指定视图对象，可选，默认为 View

class View:

    @pywss.openapi.docs(summary="获取用户列表")
    def http_get(ctx: pywss.Context):
        pass
```

  </TabItem>
  <TabItem value="role.py" label="role.py">

```python
imprt pywss

__route__="/role/{rid}"  # 指定路由，可选，默认为 /role
__view__="View"  # 指定视图对象，可选，默认为 View

class View:

    @pywss.openapi.docs(summary="获取角色列表")
    def http_get(ctx: pywss.Context):
        pass
```

  </TabItem>
  <TabItem value="permission.py" label="permission.py">

```python
import pywss

__route__="/perm"  # 指定路由，可选，默认为 /permission
__view__="View"  # 指定视图对象，可选，默认为 View

class View:

    @pywss.openapi.docs(summary="获取权限列表")
    def http_get(ctx: pywss.Context):
        pass
hello~
```

  </TabItem>
</Tabs>

此时，项目路由将转化为：
```text
- GET/api/v1/user
- GET/api/v1/role/{rid}
- GET/api/v2/perm
```

具体使用场景可参考：[pywss-be](https://github.com/czasg/pywss-react-admin-be)

<br/>

## 路由组
**Pywss** 通过 `app.party` 实现了简单的路由组，以便支持在大型项目下的多级路由管理，参考如下。

```python
import pywss

def handler(ctx: pywss.Context):
    ctx.write(ctx.route)

def main():
    app = pywss.App()

    v1 = app.party("/api/v1")  # 创建 /api/v1 路由组
    v1.get("/user", handler)  # /api/v1/user

    v2 = app.party("/api/v1")  # 创建 /api/v2 路由组
    v2.get("/user", handler)  # /api/v2/user

    app.run()

if __name__ == '__main__':
    main()
```

<br/>

## 中间件
**Pywss** 通过 `ctx.next` 实现了功能模块的链式调用，在此基础之上，拓展了中间件的能力。

让我们来实现一个简单输出请求耗时的日志中间件。代码参考如下：

```python
import time
import pywss

def logHandler(ctx: pywss.Context):
    start = int(time.time())
    ctx.next()  # 执行下一个业务模块，执行完成后会继续执行后面的代码
    ctx.log.info(f"{ctx.method}{ctx.route} cost: {int(time.time()) - start}")
```

接着我们可以通过以下三种方式来注册中间件服务：
- `app.use(logHandlerMiddleware)`：通过 `use` 方法可以注册全局生效的中间件
- `app.party("/route", logHandlerMiddleware)`：通过 `party` 路由组可以注册局部生效的中间件
- `app.get("/route", logHandlerMiddleware, handler)`：通过绑定指定路由，可以注册指定路由生效的中间件

一份完整的代码参考如下：
```python
import time
import pywss
import random

def logHandler(ctx: pywss.Context):
    start = int(time.time())
    ctx.next()  # 执行下一个业务模块，执行完成后会继续执行后面的代码
    ctx.log.info(f"{ctx.method}{ctx.route} cost: {int(time.time()) - start}")

def main():
    app = pywss.App()
    app.use(logHandler)
    app.get("*", lambda ctx: time.sleep(random.randint(1, 3)))
    app.run()

if __name__ == '__main__':
    main()
```

除此之外，**Pywss** 还内置了部分常用中间件~

```python
import pywss

app = pywss.App()

app.use(
    pywss.NewRecoverHandler(),  # recover
    pywss.NewCORSHandler(),     # cors
    pywss.NewJWTHandler(),      # jwt
)
```

<br/>

## 升级WebSocket
**WebSocket** 底层是基于 HTTP GET 升级实现，是长连接的一种实现方式。

**Pywss** 则通过 `WebSocketUpgrade` 完成此处升级。
升级后将激活 `ctx.ws_read` 和 `ctx.ws_write` 两个接口方法，并通过这两个接口方法与客户端进行交互。

让我们来实现一个简单的 **WebSocket** 升级代码，参考如下：

```python
import pywss

def websocket(ctx: pywss.Context):
    # 升级 WebSocket
    err = pywss.WebSocketUpgrade(ctx)
    if err:
        ctx.log.error(err)
        ctx.set_status_code(pywss.StatusBadRequest)
        return
    # 轮询获取消息，实际使用场景建议引入心跳/探活机制
    while True:
        data = ctx.ws_read()
        ctx.log.info(data)
        ctx.ws_write(b"hello")

def main():
    app = pywss.App()
    app.get("/websocket", websocket)
    app.run()

if __name__ == '__main__':
    main()
```

接着让我们模拟客户端，需要 `打开浏览器 -> F12 -> 进入控制台`，输入以下代码：

```
ws = new WebSocket("ws://127.0.0.1:8080/websocket");
ws.onmessage = function (ev) {
    console.log(ev.data);
}
ws.onclose = function (ev) {
    console.log('Connect Closed')
}
ws.onopen = function() {
    if (ws.readyState === WebSocket.OPEN) {
        ws.send('hello??')
    }
}
```

其他具体使用场景/用例，可以参考 [多人在线协同编辑luckysheet](https://github.com/czasg/pywss/tree/master/demo/luckysheet)、
[多人聊天室](https://github.com/czasg/pywss/tree/master/demo/chat)

<br/>

## SwaggerUI
**Pywss** 实现了部分 **OpenAPI** 的能力。

```python
import pywss

@pywss.openapi.docs(
    summary="此处是接口摘要 - 可选",
    description="此处是接口描述 - 可选",
    params={
        "page_size": "此处是参数说明",
        "username:query": "可以指定参数属于query(默认参数)",
        "name:path,required": "path表示为路径参数，required表示必填参数",
        "Auth:header,required": "参数支持：query、path、header、cookie",
    },
    request={"请求说明": "此处是请求示例"},
    response={"响应说明": "此处是响应示例"},
)
def hello(ctx: pywss.Context):
    ctx.write({
        "hello": "world",
        "page_size": ctx.url_params.get("page_size", 10),
        "username": ctx.url_params.get("username", "username"),
        "name": ctx.route_params.get("name", "name"),
        "Auth": ctx.headers.get("Auth", "Auth"),
    })

def main():
    app = pywss.App()
    app.openapi()  # 开启 openapi
    app.post("/hello/{name}", hello)
    app.run()

if __name__ == '__main__':
    main()
```
在启动服务后，
接着打开浏览器，访问 [localhost:8080/docs](http://localhost:8080/docs) 即可看到经典 SwaggerUI 界面。

<br/>

## 文件服务
**Pywss** 通过 `app.static` 实现了简单的静态文件服务器，代码参考如下：
```python
import pywss

app = pywss.App()

# 注册静态资源，需要指定文件根目录
app.static("/static", rootDir="/rootDir")

app.run()
```
启动服务后，可以通过 [localhost:8080/static/index.html](http://localhost:8080/static/index.html) 进行访问

<br/>

## 单元测试
```python
import pywss

app = pywss.App()

app.get("/test", lambda ctx: ctx.set_status_code(204))

# 基于app创建HttpRequest
req = pywss.HttpTestRequest(app)

# 发起Get请求，获取resp
resp = req.get("/test")

assert resp.status_code == 204
```
可以参考 [pywss单元测试](https://github.com/czasg/pywss/tree/master/test/test_app.py)

<br/>

## 命令行启动
如果你只是想快速且简单的起一个服务，那么你还可以通过命令`pywss`的方式：
- 查看帮助指令
```shell
pywss -h
```

- 启动静态文件服务：
    - `--static`表示`本地路径 : 路由前缀`，即将本地路径下的文件映射到指定路由
    - `--port`表示端口号
```shell
pywss --static=".:/" --port=8080
```
通过`http://localhost:8080/`访问

- 启动web服务：
    - `--route`表示`method : route : code : body`，即指定响应信息
```shell
pywss --route="GET:/hello:200:hello, world" --route="GET:/ok:204:" --port=8080
```
通过`http://localhost:8080/hello`访问

<br/>
